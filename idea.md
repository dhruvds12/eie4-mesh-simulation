# Ideas to improve message rate

## Use p-CSMA

- Use p-CSMA to reduce the number of collisions by allowing nodes to transmit with a probability p.
- This can be done by modifying the CSMA algorithm to include a probability p for each node to transmit.

## Have a timeout once transmission has completed

- Once a node has completed its transmission, it should wait for a timeout period before attempting to transmit again.
- This will allow other nodes to have a chance to transmit and reduce the number of collisions.
- The timeout period can be adjusted based on the number of nodes in the network and the expected message rate.
- This can be done by adding a timer to each node that is reset after each transmission.
- The timer can be set to a random value between a minimum and maximum value to further reduce the chance of collisions.

This is quite similar to CSMA/CA with a backoff timer which is currently implemented in the code.

## Conditional response to RREQ and UREQ
- Nodes currently respond to RREQ and UREQ if they are the destination or if they have the route to the destination.
- This can be modified to only respond if the node is the destination or if it has a route to the destination and the route is not already being used by another node.
- ALternatively, nodes can respond to RREQ and UREQ with a probability p to reduce the number of responses and collisions.
- Even better, nodes only respond to RREQ and UREQ if the destination node is greater than n hops away. This will prevent the nodes all responding to the same RREQ and UREQ if they are all within n hops of the destination.
- N should be tuned but essentially means that the message is already so close to the destination that it is not worth responding to the RREQ or UREQ and we might as well just let the message continue on its way.

| Topic                             | What you already propose                                                                                                                         | What I saw in the code                                                                                                                   | Assessment & extra suggestions                                                                                                                                                                                                                                                                                                                                                                                                                |
| --------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ | ---------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **p-persistent CSMA**             | Pick probability *p* when channel sensed idle.                                                                                                   | `BroadcastMessageCSMA` is already non-persistent – it transmits as soon as it gets an idle CCA window.                                   | Implement true *p*-persistence: after `waitClearChannel` succeeds, transmit with prob *p*, otherwise wait **exactly one slot** and repeat the CCA.  This is closer to the classic LoRaWAN “regional-duty-cycle + LBT” designs and has two benefits: (1) bounded latency, (2) lower chance of synchronised retries (near-far capture). Give every node a moving estimate of channel busy ratio β and adapt *p*≈min{1,(1–β) · N⁻¹}.             |
| **Post-Tx guard / timeout**       | Fixed random timeout per node.                                                                                                                   | Back-off is only used when channel was busy *before* sending.  After a successful Tx the node goes to the head of `txQueue` immediately. | Keep the *guard* but make it proportional to (payload airtime + backhaul RTT estimate).  A simple and effective variant is “ε-persist”: after each Tx do **one blind CCA** just like at the beginning of a new Tx attempt.  This gives other nodes one slot to seize the medium without imposing a full back-off delay.                                                                                                                       |
| **Conditional RREQ/UREQ replies** | (i) reply only if node is destination, or (ii) if route is cached *and* not in use, or (iii) probabilistically, or (iv) only if > *n* hops away. | Current router replies from **any** intermediate node that has a route (`handleRREQ` and `handleUREQ`).                                  | 1. Implement **expanding-ring search (ERS)**: originate RREQ with TTL = *k*, double TTL on timeout until max.  Reduces broadcast storm far more effectively than probability hacks and is standard in AODV. 2. Keep intermediate-node replies but add a **freshness field** (sequence no.+expiry) so stale routes aren’t propagated. 3. Your > *n*-hops rule is a special case of ERS; once ERS is in place the extra heuristic is redundant. |
| **Reducing control overhead**     | Diff-broadcast of user presence (`SendDiffBroadcastInfo`).                                                                                       | Implemented and already much cheaper than full HELLO.                                                                                    | You can push this further: piggy-back diff info on regular data packets whenever possible (≈ “route caching by overhearing”).                                                                                                                                                                                                                                                                                                                 |
| **Collision detection**           | Network model drops a packet if *any* overlapping Tx is in range.                                                                                | Accurate enough for a first-order model.                                                                                                 | To squeeze higher throughput you will eventually need **capture effect** (LoRa can often decode the stronger of two overlapping frames).  Add RSSI to `Transmission` and let the receiver succeed if P<sub>desired</sub> − P<sub>interferer</sub> ≥ ∆.                                                                                                                                                                                        |
| **MAC back-off scheme**           | Binary exponential (default) or BE.                                                                                                              | Parameterised in YAML – nice.                                                                                                            | Add **stickiness** (retain the current back-off exponent if the previous attempt also failed) and a **cut-off** after *m* retries to avoid infinite loops.  Both increase goodput when the network is saturated.                                                                                                                                                                                                                              |
| **Reliability / ACKs**            | Explicit ACKs disabled; implicit by overhearing next hop.                                                                                        | Works, but pending-Tx time-outs cause many false route errors.                                                                           | 1. Keep the implicit ACK but **extend the overhearing window** to `(airtime_next_hop + propagation + CCA_window)`.  2. For unicast payloads > \~50 B use *selective‐repeat ACK*: only ACK every *k* packets or when buffer is full – lowers overhead at high rates.                                                                                                                                                                           |
| **Miscellaneous**                 | –                                                                                                                                                | –                                                                                                                                        | *Priority queues*: take advantage of the `txQueue` already present – order DATA ahead of ROUTING control when backlog > λ.  This helps during bursts.                                                                                                                                                                                                                                                                                         |
